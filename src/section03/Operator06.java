package section03;
/*
 * 6. 비트 연산자
 * 	2진수로 표현된 두 비트 연산자
 * 
 * 	& : 대응되는 비트가 모두 1이면 1을 반환(비트 AND연산자)
 * 	| : 대응되는 비트 중에서 하나라도 1이면 1을 반환(비트 OR연산자)
 *  ^ : 대응되는 비트가 서로 다르면 1을 반환(비트 XOR연산자-EXCLUSIVE OR)
 *  ~ : 대응되는 비트가 1이면 0으로, 0이면 1로 반전시킴(비트 NOT연산자)
 *  
 *  줄복사 : Alt + Ctrl + 방향키
 *  줄삭제 : Ctrl + d
 */
public class Operator06 {
	public static void main(String[] args) {
		int num1 = 3; // 2진수로 표현하면 0 0011(=3)  앞에 0은 부호비트이다. 부호비트가 1이면 -라는 뜻.
		int num2 = 5; // 2진수로 표현하면 0 0101(=5)
		                       /*     | ||||
		                       * &라면   0001 -> 10진수로 표현하면 1
		                       * |라면   0111 -> 10진수로 표현하면 7
		                       * ^라면   0110 -> 10진수로 표현하면 6
		                       * 
		                       * 3 =  0 0011
		                       * ~라면 1 1100 -> 10진수로 표현하면 -12가 예상. 근데 -4가 나옴.
		                       * 이유: 컴퓨터는 음수를 2의 보수로 생각한다. 2의보수 = 1의보수에 1을 더한것.
		                       * 컴퓨터는 + 밖에 못한다. ex. 5 + (-3) = 2
		                       * 4 : 0 0100인데(1의 보수), 음수로 변환하면(반전)
		                       * 	 1 1011이 된다. 여기서 2의 보수로 변환하면 1을 더하게 되어
		                       * 	 1 1100이 된다. 이래서 -4가 나오는것이다.
		                       */
		
		System.out.println("num1 & num2: " + (num1 & num2));
		System.out.println("num1 | num2: " + (num1 | num2));
		System.out.println("num1 ^ num2: " + (num1 ^ num2));
		
		System.out.println("~num1: " + ~num1);
	}
}
